--- a/lidar/intensity_model.py
+++ b/lidar/intensity_model.py
@@ -171,7 +171,6 @@
     uv_layer = mesh.uv_layers.active
     inv_world = eval_obj.matrix_world.inverted()
     hit_local = inv_world @ hit_world
-    mesh.calc_loop_triangles()
     for tri in mesh.loop_triangles:
         if tri.polygon_index != poly_index:
             continue
@@ -213,7 +212,7 @@
 def _material_has_textures(node):
     if node is None:
         return False
-    for name in ("Base Color", "Roughness", "Metallic", "Transmission", "Alpha"):
+    for name in ("Base Color", "Roughness", "Metallic", "Transmission", "Alpha", "Transmission Roughness"):
         sock = node.inputs.get(name)
         if sock and sock.is_linked:
             return True
@@ -222,8 +221,7 @@
 
 def get_material_from_hit(obj: bpy.types.Object, poly_index: int, depsgraph) -> bpy.types.Material | None:
     try:
-        eval_obj = obj.evaluated_get(depsgraph)
-        mesh = eval_obj.data
+        eval_obj, mesh = _get_eval_and_mesh(obj, depsgraph)
         if not hasattr(mesh, "polygons") or poly_index < 0:
             return None
         poly = mesh.polygons[poly_index]
--- a/lidar/lidar_raycast.py
+++ b/lidar/lidar_raycast.py
@@ -113,27 +113,6 @@
         if nrm_world.length_squared > 1e-12:
             return nrm_world.normalized()
     return fallback_normal
-    mesh = eval_obj.data
-    mesh.calc_normals_split()
-    mesh.calc_loop_triangles()
-    inv_world = eval_obj.matrix_world.inverted()
-    hit_local = inv_world @ hit_world
-    for tri in mesh.loop_triangles:
-        if tri.polygon_index != poly_index:
-            continue
-        verts = [mesh.vertices[i].co for i in tri.vertices]
-        bary = _barycentric_coords(verts, hit_local)
-        if bary is None:
-            continue
-        loops = tri.loops
-        normal_local = Vector((0.0, 0.0, 0.0))
-        for weight, loop_index in zip(bary, loops):
-            normal_local += weight * mesh.loops[loop_index].normal
-        normal_world = eval_obj.matrix_world.to_3x3() @ normal_local
-        if normal_world.length_squared > 1e-12:
-            return normal_world.normalized()
-    return fallback_normal
-
 def _beer_lambert_transmittance(obj, depsgraph, entry_loc, direction_world, bias, extinction_coeff):
     if extinction_coeff <= 0.0:
         return 1.0
